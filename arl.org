#+title: ARL - Issue tracker
#+date: 2026-01-23

* TODO Write a minimum working transpiler
We need to be able to compile the following file:
[[file:examples/hello-world.arl]].  All it does is print "Hello,
world!".  Should be relatively straightforward.
** Stages
We need the following stages in our MVP transpiler:
- Source code reading (read bytes from a file)
- Parse raw bytes into tokens (Lexer)
- Interpret tokens into a classical AST (Parser)
- Stack effect and type analysis of the AST for soundness
- Translate AST into C code (Codegen)
- Compile C code into native executable (Target)

It's a Eulerian Path from the source code to the native executable.
** DONE Read file
** DONE Lexer
[[file:src/lexer/]]
[[file:include/arl/lexer/]]
** WIP Parser
[[file:src/parser/]]
[[file:include/arl/parser/]]

We need to generate some form of AST from the token stream.  We want
something a stage above the tokeniser so it should distinguish the
following cases:
- Literal value
- Primitive call
*** TODO AST design
*** TODO Token Stream to AST implementation
** TODO Stack effect/type analysis
[[file:src/analysis/]]
[[file:include/arl/analysis/]]

Given the AST, we need to verify the soundness of it with regards to
types and the stack.  We have this idea of "stack effects" attached to
every node in the AST; literals push values onto the stack and pop
nothing, while operations may pop some operands and push some values.

We need a way to:
- Codify the stack effects of each type of AST node
- Infer the total stack effect from a sequence of nodes

These stack effects work in tandem with our type analysis.  Stack
shape analysis tells us what operands are being fed into primitives,
while the type analysis will tell us if the operands are well formed
for the primitives.
** TODO Code generator
[[file:src/codegen/]]
[[file:include/arl/codegen/]]

This should take the AST generated by the parser (which should already
have been analysed), and write equivalent C code.
** TODO Target compilation
[[file:src/target/]]
[[file:include/arl/target/]]

=gcc= and =clang= take C code via /stdin/, so we don't need to write
the C code to disk - we can just leave it as a buffer of bytes.  So
we'll call the compilers and feed the generated code from the previous
stage into it via stdin.
